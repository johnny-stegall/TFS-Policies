using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;
using EnvDTE;
using Microsoft.TeamFoundation.VersionControl.Client;
using Microsoft.VisualStudio.Coverage.Analysis;
using TFS.Policies.UI;

namespace TFS.Policies
{
  [Serializable]
  public class CodeCoverage : PolicyBase
  {
    #region Variable Declarations
    private const string TEST_RESULTS_FOLDER = "TestResults";
    private const string NO_TEST_RESULTS = "No test coverage results were found.";
    private const string MULTIPLE_COVERAGE_FILES = "Multiple coverage files were found.";

    private int _coverageThreshold = 80;
    #endregion

    #region PolicyBase Properties
    public override bool CanEdit
    {
      get
      {
        return true;
      }
    }

    public override string Description
    {
      get
      {
        return "Requires checked-in code to pass a certain threshold of unit test code coverage.";
      }
    }

    public override string InstallationInstructions
    {
      get
      {
        return "Execute install.cmd";
      }
    }

    public override string Type
    {
      get
      {
        return "Code Coverage Policy";
      }
    }

    public override string TypeDescription
    {
      get
      {
        return this.Description;
      }
    }
    #endregion Properties

    #region PolicyBase Methods
    public override bool Edit(IPolicyEditArgs policyEditArgs)
    {
      if (policyEditArgs == null)
        throw new ArgumentNullException("policyEditArgs");

      using (var dialog = new ConfigureCoverage())
      {
        dialog.CoverageThreshold = _coverageThreshold;
        if (dialog.ShowDialog(policyEditArgs.Parent) == DialogResult.OK)
        {
          _coverageThreshold = dialog.CoverageThreshold;
          return true;
        }
        else
          return false;
      }
    }

    public override PolicyFailure[] Evaluate()
    {
      var failures = new List<PolicyFailure>();

      var visualStudio = this.PendingCheckin.GetService(typeof(_DTE)) as _DTE;

      if (visualStudio.Solution != null && !string.IsNullOrEmpty(visualStudio.Solution.FullName))
      {
        string solutionPath = Path.GetDirectoryName(visualStudio.Solution.FullName);
        string testResultsPath = GetTestResultsPath(solutionPath);

        if (testResultsPath == null)
          failures.Add(new PolicyFailure(NO_TEST_RESULTS, this));
        else
        {
          string coverageFile = GetCodeCoverageFile(testResultsPath);

          if (string.IsNullOrEmpty(coverageFile))
            failures.Add(new PolicyFailure(NO_TEST_RESULTS, this));
          else
          {
            var codeCoverage = CalculateTotalCoverage(coverageFile);

            if (codeCoverage == 0)
              failures.Add(new PolicyFailure(NO_TEST_RESULTS, this));
            else if (codeCoverage < _coverageThreshold)
            {
              failures.Add(new PolicyFailure(
                string.Format("Required code coverage is: {0:0}%.\nYour code coverage is: {1:##0.00}%.",
                  _coverageThreshold,
                  codeCoverage),
                this));
            }
          }
        }
      }

      return failures.ToArray();
    }
    #endregion

    #region Private Methods
    /// <summary>
    /// Calculates total code coverage.
    /// </summary>
    /// <remarks>
    /// There are two metrics: lines covered and blocks covered. Blocks
    /// covered is the finer metric, because a single line can have multiple
    /// code blocks.
    /// </remarks>
    /// <param name="coverageFile">A coverage file generated by Visual
    /// Studio.</param>
    /// <returns>The code coverage as a percentage.</returns>
    private double CalculateTotalCoverage(string coverageFile)
    {
      uint blocksCovered = 0;
      uint blocksNotCovered = 0;

      using (CoverageInfo info = CoverageInfo.CreateFromFile(coverageFile))
      {
        List<BlockLineRange> lines = new List<BlockLineRange>();

        foreach (ICoverageModule module in info.Modules)
        {
          byte[] coverageBuffer = module.GetCoverageBuffer(null);

          using (ISymbolReader reader = module.Symbols.CreateReader())
          {
            uint methodId;
            string methodName;
            string undecoratedMethodName;
            string className;
            string namespaceName;

            lines.Clear();

            while (reader.GetNextMethod(out methodId, out methodName, out undecoratedMethodName, out className, out namespaceName, lines))
            {
              CoverageStatistics stats = CoverageInfo.GetMethodStatistics(coverageBuffer, lines);

              System.Diagnostics.Debug.WriteLine("Blocks Covered: " + stats.BlocksCovered);
              System.Diagnostics.Debug.WriteLine("Blocks Not Covered: " + stats.BlocksNotCovered);

              blocksCovered += stats.BlocksCovered;
              blocksNotCovered += stats.BlocksNotCovered;

              lines.Clear();
            }
          }
        }
      }

      if (blocksCovered + blocksNotCovered == 0)
        return 0.0;
      else
        return ((double)blocksCovered / (double)(blocksCovered + blocksNotCovered)) * 100.0;
    }

    /// <summary>
    /// Locates the code coverage file. 
    /// </summary>
    /// <param name="testResultsPath">The test results path.</param>
    /// <returns>The full path to the code coverage file.</returns>
    private string GetCodeCoverageFile(string testResultsPath)
    {
      var resultsInfo = new DirectoryInfo(testResultsPath);
      FileInfo[] coverageFiles = resultsInfo.GetFiles("*.coverage", SearchOption.AllDirectories);

      if (coverageFiles.Length == 0)
        return null;
      else if (coverageFiles.Length > 1)
        throw new NotSupportedException(MULTIPLE_COVERAGE_FILES);

      return coverageFiles[0].FullName;
    }

    /// <summary>
    /// Gets the full path to the test results directory.
    /// </summary>
    /// <param name="solutionPath">The solution path.</param>
    /// <returns>The full path to the results directory.</returns>
    private string GetTestResultsPath(string solutionPath)
    {
      string testResultsFolder = Path.Combine(solutionPath, TEST_RESULTS_FOLDER);

      if (Directory.Exists(testResultsFolder))
      {
        var testFolderInfo = new DirectoryInfo(testResultsFolder);
        DirectoryInfo[] pathDirectories = testFolderInfo.GetDirectories();
        if (pathDirectories.Length == 0)
          return null;

        if (pathDirectories.Length > 1)
        {
          // Sort by last write time
          Array.Sort<DirectoryInfo>(pathDirectories, delegate(DirectoryInfo x, DirectoryInfo y)
          {
            return y.LastWriteTime.CompareTo(x.LastWriteTime);
          });
        }

        return pathDirectories[0].FullName;
      }

      return null;
    }
    #endregion
  }
}
